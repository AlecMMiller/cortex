// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
  async getNote(uuid: NoteId): Promise<Result<Note, Error>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_note', { uuid }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getAllNotes(): Promise<Result<NoteTitle[], Error>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_all_notes') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async updateNote(uuid: NoteId, body: string): Promise<Result<null, Error>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('update_note', { uuid, body }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getNotesByTitle(
    title: string,
    maxResults: number,
  ): Promise<Result<NoteTitle[], Error>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_notes_by_title', { title, maxResults }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getNotesByContent(
    content: string,
    maxResults: number,
    snippetSize: number,
  ): Promise<Result<TitleWithContext[], Error>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_notes_by_content', {
          content,
          maxResults,
          snippetSize,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async createNote(title: string): Promise<Result<Note, Error>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('create_note', { title }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async renameNote(uuid: NoteId, title: string): Promise<Result<null, Error>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('rename_note', { uuid, title }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getDirectTags(uuid: NoteId): Promise<Result<Tag[], Error>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_direct_tags', { uuid }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async addNewTag(uuid: NoteId, tagText: string): Promise<Result<null, Error>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('add_new_tag', { uuid, tagText }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async addTag(noteUuid: NoteId, tagUuid: TagId): Promise<Result<null, Error>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('add_tag', { noteUuid, tagUuid }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getAllSchemas(): Promise<Result<Schema[], Error>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_all_schemas') }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getSchema(uuid: SchemaId): Promise<Result<Schema, Error>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_schema', { uuid }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async createSchema(name: string): Promise<Result<Schema, Error>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('create_schema', { name }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getSetting(key: string): Promise<Result<Setting, Error>> {
    try {
      return { status: 'ok', data: await TAURI_INVOKE('get_setting', { key }) }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getSettingOrSet(
    key: string,
    value: string,
  ): Promise<Result<Setting, Error>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_setting_or_set', { key, value }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async updateSetting(
    key: string,
    value: string,
  ): Promise<Result<null, Error>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('update_setting', { key, value }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
  async getAvailableTagsContaining(
    content: string,
    maxResults: number,
    noteUuid: NoteId,
  ): Promise<Result<[Tag[], boolean], Error>> {
    try {
      return {
        status: 'ok',
        data: await TAURI_INVOKE('get_available_tags_containing', {
          content,
          maxResults,
          noteUuid,
        }),
      }
    } catch (e) {
      if (e instanceof Error) throw e
      else return { status: 'error', error: e as any }
    }
  },
}

/** user-defined events **/

/** user-defined constants **/

/** user-defined types **/

export type AbsoluteTimestamp = string
export type Error = { type: 'Tantivy' } | { type: 'Diesel' } | { type: 'Serde' }
export type Note = {
  uuid: NoteId
  title: string
  body: string
  created_at: AbsoluteTimestamp
  updated_at: AbsoluteTimestamp
}
export type NoteId = string
export type NoteTitle = { uuid: NoteId; title: string }
export type Schema = { uuid: SchemaId; name: string }
export type SchemaId = string
export type Setting = { key: string; value: string }
export type Tag = { uuid: TagId; title: string }
export type TagId = string
export type TitleWithContext = { title: NoteTitle; context: string }

/** tauri-specta globals **/

import {
  invoke as TAURI_INVOKE,
  Channel as TAURI_CHANNEL,
} from '@tauri-apps/api/core'
import * as TAURI_API_EVENT from '@tauri-apps/api/event'
import { type WebviewWindow as __WebviewWindow__ } from '@tauri-apps/api/webviewWindow'

type __EventObj__<T> = {
  listen: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.listen<T>>
  once: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.once<T>>
  emit: null extends T
    ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
    : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>
}

export type Result<T, E> =
  | { status: 'ok'; data: T }
  | { status: 'error'; error: E }

function __makeEvents__<T extends Record<string, any>>(
  mappings: Record<keyof T, string>,
) {
  return new Proxy(
    {} as unknown as {
      [K in keyof T]: __EventObj__<T[K]> & {
        (handle: __WebviewWindow__): __EventObj__<T[K]>
      }
    },
    {
      get: (_, event) => {
        const name = mappings[event as keyof T]

        return new Proxy((() => {}) as any, {
          apply: (_, __, [window]: [__WebviewWindow__]) => ({
            listen: (arg: any) => window.listen(name, arg),
            once: (arg: any) => window.once(name, arg),
            emit: (arg: any) => window.emit(name, arg),
          }),
          get: (_, command: keyof __EventObj__<any>) => {
            switch (command) {
              case 'listen':
                return (arg: any) => TAURI_API_EVENT.listen(name, arg)
              case 'once':
                return (arg: any) => TAURI_API_EVENT.once(name, arg)
              case 'emit':
                return (arg: any) => TAURI_API_EVENT.emit(name, arg)
            }
          },
        })
      },
    },
  )
}
